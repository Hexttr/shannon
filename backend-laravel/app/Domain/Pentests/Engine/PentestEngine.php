<?php

namespace App\Domain\Pentests\Engine;

use App\Models\Pentest;
use App\Services\ClaudeApiService;
use App\Services\SshClientService;
use Illuminate\Support\Facades\Log;

class PentestEngine
{
    private const WORKFLOW_STEPS = [
        'nmap' => 'Сканирование портов (Nmap)',
        'nikto' => 'Сканирование веб-сервера (Nikto)',
        'nuclei' => 'Сканирование уязвимостей (Nuclei)',
        'dirb' => 'Перебор директорий (Dirb)',
        'sqlmap' => 'Проверка SQL инъекций (SQLMap)',
    ];

    public function __construct(
        private SshClientService $sshClient,
        private ClaudeApiService $claudeApi
    ) {
    }

    public function run(Pentest $pentest): void
    {
        try {
            $this->checkSelfScanning($pentest);

            foreach (self::WORKFLOW_STEPS as $step => $stepName) {
                $this->setStep($pentest, $step, 'running');

                try {
                    $result = $this->runStep($step, $pentest);
                    $this->setStep($pentest, $step, 'completed');

                    // Анализ результатов через Claude API
                    $this->analyzeResults($pentest, $step, $result);
                } catch (\Exception $e) {
                    Log::error("Ошибка выполнения шага {$step}: " . $e->getMessage());
                    $this->setStep($pentest, $step, 'failed');
                    // Продолжаем выполнение следующих шагов
                }
            }

            $pentest->update([
                'status' => 'completed',
                'completed_at' => now(),
            ]);

            $this->broadcastStatus($pentest, 'completed');
        } catch (\Exception $e) {
            Log::error("Критическая ошибка пентеста: " . $e->getMessage());
            $pentest->update([
                'status' => 'failed',
                'completed_at' => now(),
            ]);
            $this->broadcastStatus($pentest, 'failed');
        }
    }

    private function checkSelfScanning(Pentest $pentest): void
    {
        $targetUrl = parse_url($pentest->target_url, PHP_URL_HOST);
        $serverHost = parse_url(config('app.url'), PHP_URL_HOST);

        if ($targetUrl === $serverHost) {
            throw new \RuntimeException('Попытка сканирования самого себя (self-scanning)');
        }
    }

    private function setStep(Pentest $pentest, string $step, string $status): void
    {
        $stepProgress = $pentest->step_progress ?? [];
        $stepProgress[$step] = $status;

        $pentest->update([
            'current_step' => $step,
            'step_progress' => $stepProgress,
        ]);

        $this->broadcastStatus($pentest, 'running');
    }

    private function runStep(string $step, Pentest $pentest): string
    {
        $targetUrl = $pentest->target_url;
        $outputFile = "/tmp/{$step}_{$pentest->id}.txt";

        return match ($step) {
            'nmap' => $this->runNmapScan($targetUrl, $outputFile),
            'nikto' => $this->runNiktoScan($targetUrl, $outputFile),
            'nuclei' => $this->runNucleiScan($targetUrl, $outputFile),
            'dirb' => $this->runDirbScan($targetUrl, $outputFile),
            'sqlmap' => $this->runSqlmapScan($targetUrl, $outputFile),
            default => throw new \InvalidArgumentException("Неизвестный шаг: {$step}"),
        };
    }

    private function runNmapScan(string $targetUrl, string $outputFile): string
    {
        $host = parse_url($targetUrl, PHP_URL_HOST);
        $command = "nmap -sV -sC -oN {$outputFile} {$host}";
        return $this->sshClient->execute($command);
    }

    private function runNiktoScan(string $targetUrl, string $outputFile): string
    {
        $command = "nikto -h {$targetUrl} -o {$outputFile} -Format txt";
        return $this->sshClient->execute($command);
    }

    private function runNucleiScan(string $targetUrl, string $outputFile): string
    {
        $command = "nuclei -u {$targetUrl} -o {$outputFile}";
        return $this->sshClient->execute($command);
    }

    private function runDirbScan(string $targetUrl, string $outputFile): string
    {
        $command = "dirb {$targetUrl} -o {$outputFile}";
        return $this->sshClient->execute($command);
    }

    private function runSqlmapScan(string $targetUrl, string $outputFile): string
    {
        $command = "sqlmap -u {$targetUrl} --batch --output-dir=/tmp/sqlmap_{$outputFile}";
        return $this->sshClient->execute($command);
    }

    private function analyzeResults(Pentest $pentest, string $step, string $results): void
    {
        try {
            $analysis = $this->claudeApi->analyzeScanResults($step, $results, $pentest->target_url);

            foreach ($analysis['vulnerabilities'] ?? [] as $vuln) {
                $pentest->vulnerabilities()->create([
                    'title' => $vuln['title'] ?? 'Unknown',
                    'description' => $vuln['description'] ?? '',
                    'severity' => $vuln['severity'] ?? 'low',
                    'cvss_score' => $vuln['cvss_score'] ?? null,
                    'cve' => $vuln['cve'] ?? null,
                    'solution' => $vuln['solution'] ?? null,
                ]);
            }
        } catch (\Exception $e) {
            Log::warning("Ошибка анализа результатов через Claude API: " . $e->getMessage());
            // Продолжаем выполнение даже при ошибке API
        }
    }

    private function broadcastStatus(Pentest $pentest, string $status): void
    {
        // Используем Laravel Broadcasting для WebSocket
        broadcast(new \App\Events\PentestStatusUpdated($pentest, $status));
    }
}

