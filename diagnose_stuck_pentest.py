#!/usr/bin/env python3
"""
Диагностика зависшего пентеста
"""

import paramiko

SSH_HOST = "72.56.79.153"
SSH_USER = "root"
SSH_PASSWORD = "m8J@2_6whwza6U"

def main():
    print("="*60)
    print("ДИАГНОСТИКА ЗАВИСШЕГО ПЕНТЕСТА")
    print("="*60)
    
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(SSH_HOST, username=SSH_USER, password=SSH_PASSWORD, timeout=30)
    
    try:
        # 1. Проверяем статус в БД
        print("\n1. СТАТУС В БАЗЕ ДАННЫХ:")
        stdin, stdout, stderr = ssh.exec_command("sqlite3 /root/shannon/backend/shannon.db 'SELECT id, status, current_step, step_progress FROM pentests WHERE id = 2;'")
        db_status = stdout.read().decode('utf-8', errors='replace')
        print(f"  {db_status}")
        
        # 2. Проверяем процессы
        print("\n2. ПРОЦЕССЫ:")
        stdin, stdout, stderr = ssh.exec_command("ps aux | grep -E 'dirb|nmap|nikto|nuclei|sqlmap' | grep -v grep")
        processes = stdout.read().decode('utf-8', errors='replace')
        if processes:
            print("  Найдены процессы:")
            for proc in processes.strip().split('\n'):
                if proc:
                    print(f"    {proc[:150]}")
        else:
            print("  [WARNING] Нет активных процессов сканирования")
        
        # 3. Проверяем файлы результатов
        print("\n3. ФАЙЛЫ РЕЗУЛЬТАТОВ:")
        stdin, stdout, stderr = ssh.exec_command("ls -lh /tmp/*_2.txt 2>/dev/null")
        result_files = stdout.read().decode('utf-8', errors='replace')
        if result_files:
            print("  Найдены файлы:")
            for file in result_files.strip().split('\n'):
                if file:
                    print(f"    {file}")
        else:
            print("  Файлы результатов не найдены")
        
        # 4. Проверяем последние логи dirb
        print("\n4. ЛОГИ DIRB:")
        stdin, stdout, stderr = ssh.exec_command("sqlite3 /root/shannon/backend/shannon.db 'SELECT timestamp, message FROM logs WHERE pentest_id = 2 AND message LIKE \"%dirb%\" OR message LIKE \"%Dirb%\" ORDER BY timestamp DESC LIMIT 10;'")
        dirb_logs = stdout.read().decode('utf-8', errors='replace')
        if dirb_logs:
            for log in dirb_logs.strip().split('\n')[:10]:
                if log:
                    safe_log = log.encode('ascii', 'replace').decode('ascii')
                    print(f"    {safe_log[:150]}")
        
        # 5. Проверяем файл dirb
        print("\n5. ФАЙЛ DIRB:")
        stdin, stdout, stderr = ssh.exec_command("ls -lh /tmp/dirb_2.txt 2>/dev/null && tail -10 /tmp/dirb_2.txt 2>/dev/null")
        dirb_file = stdout.read().decode('utf-8', errors='replace')
        if dirb_file:
            print(f"  {dirb_file[:500]}")
        else:
            print("  Файл не найден")
        
        # 6. Проверяем backend процесс
        print("\n6. BACKEND ПРОЦЕСС:")
        stdin, stdout, stderr = ssh.exec_command("ps aux | grep -E 'uvicorn|python.*app.main' | grep -v grep")
        backend_proc = stdout.read().decode('utf-8', errors='replace')
        if backend_proc:
            print(f"  [OK] Backend работает: {backend_proc[:150]}")
        else:
            print("  [ERROR] Backend не запущен")
        
        # 7. Проверяем когда был последний лог
        print("\n7. ПОСЛЕДНИЙ ЛОГ:")
        stdin, stdout, stderr = ssh.exec_command("sqlite3 /root/shannon/backend/shannon.db 'SELECT timestamp, level, message FROM logs WHERE pentest_id = 2 ORDER BY timestamp DESC LIMIT 1;'")
        last_log = stdout.read().decode('utf-8', errors='replace')
        if last_log:
            print(f"  {last_log[:200]}")
        
        print("\n" + "="*60)
        print("РЕКОМЕНДАЦИИ")
        print("="*60)
        print("\nЕсли пентест завис:")
        print("  1. Проверьте логи на наличие ошибок")
        print("  2. Проверьте файлы результатов в /tmp/")
        print("  3. Возможно dirb завершился, но анализ через Claude не прошел")
        print("  4. Можно перезапустить пентест или завершить его вручную")
        
    finally:
        ssh.close()

if __name__ == "__main__":
    main()

